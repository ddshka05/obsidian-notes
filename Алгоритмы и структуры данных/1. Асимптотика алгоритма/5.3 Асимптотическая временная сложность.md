## Алгоритмы с логарифмической сложностью
**Пример 1.** Определим временную сложность алгоритма для проверки того, является ли число точной степенью числа 2:

```python
def is_power_of_two(n): 
	i = 1
	while i < n: 
		i = i * 2 
	return i == n
```

Алгоритм содержит цикл, однако не так просто сказать, сколько итераций он совершает. 

1. Пусть число является степенью 2:
По условию цикла понятно, что он выполняется до тех пор, пока значение переменной `i` не станет равным или больше входного числа `n`. Значение переменной `i` изначально равняется единице и на каждой итерации цикла увеличивается в 2 раза: на первой итерации значение переменной `i` становится равным 2, на второй – 4, на третьей – 8, на четвертой – 16 и так далее. Отсюда несложно увидеть, что если входное число n равняется 2, то цикл совершает 1 итерацию, если 4 – 2 итерации, если 8 – 3 итерации, если 16 – 4 итерации и так далее. Исходя из этого можно заключить, что если входное число nn является точной степенью числа 2, то цикл совершает $\log_{2}​{n}$ итераций.

2. Пусть число не является степенью 2:
Теперь выясним, сколько итераций совершает цикл, если входное число n не является точной степенью числа 2. Предположим, что n=14. Тогда найдем ближайшие степени числа 2 слева и справа от числа 14. Это числа 8 и 16. Поскольку при n=8 цикл совершает 3 итерации , а при n=16 – 4 итерации, то количество итераций цикла при n=14 точно будет не меньше 3 и не больше 4, то есть будет равняться либо 3, либо 4. Явно выполнив алгоритм, получим, что при n=14 цикл совершает ровно 4 итерации.
	 За 3 итерации `i` становится равным 8, потом на 4 итерации `i` становится равной 16, цикл прекращается, потому что число `16 > 14` -> функция возвращает `False`.

Несложно понять, что аналогичным образом мы можем оценить количество итераций цикла при любом n. Исходя из этого можно заключить, что если входное число nn не является точной степенью числа 2, то цикл совершает $\lceil\log⁡_{2}{n}\rceil$ итераций.

Итак, если входное число nn является точной степенью числа 2, то цикл внутри алгоритма совершает $\log⁡_{2}{n}$ итераций, если не является – $\lceil\log⁡_{2}{n}\rceil$ итераций. Нам важно, сколько итераций совершает цикл в худшем случае, поэтому мы говорим, что цикл совершает $\lceil\log⁡_{2}{n}\rceil$ итераций. На каждой итерации цикл выполняет фиксированное количество простейших операций, независимо от размера входных данных, поэтому эти операции можно не учитывать и брать в расчет только количество итераций цикла. 

Таким образом, учитывая только количество итераций цикла, равное значению $\lceil\log⁡_{2}{n}\rceil$, получим, что временная сложность алгоритма равна O($\log⁡{n}$).

***Примерно так и надо определять сложность алгоритмов за логарифм.***

### Важное примечание из вышеописанного 
Получается, если внутри алгоритма содержится цикл, счетчик которого на каждой итерации увеличивается или уменьшается в a раз, то количество итераций такого цикла равняется значению $log_{a}​{n}$, округленному вверх до ближайшего целого числа.

**Пример:**
Имеется такой алгоритм
```python
def algorithm(n): 
	i1 = 1 i2 = 1 
	count1 = 0 
	count2 = 0 
	# первый цикл
	while i1 < n: 
		i1 = i1 * 7 
		count1 = count1 + 1 
	# второй цикл
	while i2 < n: 
		i2 = i2 * 8 
		count2 = count2 + 1 
	return count1 - count2
```

Видим счетчик в двух циклах, которые увеличиваются с каждой итерацией в 7 и 8 раз соответственно. 

Получается, что количество итераций в худшем случае первого цикла $\lceil\log_{7}{n}\rceil$, а второго $\lceil\log_{8}{n}\rceil$. 

