## Функция временной эффективности

В этом уроке мы рассмотрим другой подход к оценке – **теоретический**.

Теоретический способ позволяет оценить временную эффективность алгоритма, не проводя эксперименты по измерению времени его выполнения.

Он подразумевает выполнение следующих шагов:

- **Шаг 1.** Записать алгоритм в виде программы на одном из высокоуровневых языков программирования (например, Python)
- **Шаг 2.** Перевести программу в последовательность [машинных команд](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4)
- **Шаг 3.** Определить для каждой машинной команды i время t(i), необходимое для ее выполнения
- **Шаг 4.** Определить для каждой машинной команды i количество повторений команды n(i)​ за время выполнения алгоритма
- **Шаг 5.** Определить произведение t(i)⋅n(i)​ всех машинных команд, что в сумме и будет составлять время выполнения алгоритма

Таким образом, с помощью теоретического подхода можно определить точное время выполнения любого алгоритма без его запуска. Но в таком виде этот подход является слишком сложным, так как требует досконального знания машинных команд, создаваемых средой, в которой выполняется алгоритм.

### Упрощение теоретического анализа

Процесс оценки временной эффективности алгоритма теоретическим способом можно упростить, если не опускаться до уровня машинных команд, а проводить анализ непосредственно программы, написанной на языке высокого уровня. 

#### Простейшие операции высокого уровня

Выделим **простейшие операции высокого уровня**, которые в целом не зависят от используемого языка программирования:

- возврат значения из функции (`return a`)
- выполнение арифметической операции (`a + b`)
- сравнение двух чисел (`a >= b`)
- присваивание значения переменной (`a = 3`)
- индексация списка (`data[0]`)

Простейшие операции соответствуют определенным машинным командам. И хотя время их выполнения зависит от аппаратного и программного обеспечения, оно является постоянной известной величиной. 

#### Приступим к анализу!

Если допустить, что *время выполнения всех простейших операций примерно одинаково*, то можно просто подсчитать их количество и использовать полученное значение в качестве критерия оценки времени выполнения алгоритма в условиях конкретного аппаратного и программного обеспечения.

Пусть количество простейших операций, выполняемых внутри алгоритма, определяется функцией k(n), где n – размер входных данных. 

Тогда время выполнения этого алгоритма T на устройстве, которое на совершение одной простейшей операции затрачивает t единиц времени, можно выразить так:

	T(n) = t⋅k(n)

Полученную функцию T(n) можно использовать для описания временной эффективности алгоритма. При этом параметр t можно опустить, так как его значение определяется условиями конкретного аппаратного и программного обеспечения и прямого отношения к алгоритму не имеет.

Таким образом, временную эффективность алгоритма можно описать с помощью функции, которая размеру входных данных сопоставляет количество простейших операций, выполняемых внутри алгоритма:

	T(n) = k(n)

Такая функция называется **функцией временной эффективности**.

## Составление функции временной эффективности

Рассмотрим алгоритм `find_max()`, предназначенный для нахождения максимального элемента в списке чисел `data`:

![[Pasted image 20250424182422.png]]

1. **Инициализация `max_value = data[0]`.** На данном этапе выполняются две простейшие операции:
- индексация списка: `data[0]`
- присваивание значения переменной: `max_value = ...`

Итого: `count = 2`.

2. **Цикл `for elem in data`.** Цикл совершает `n` итераций, где `n` – длина списка `data`. На каждой итерации цикла выполняются две или три простейшие операции:

- присваивание значения переменной: `for elem`
- сравнение двух чисел: `if elem >= max_value`
- присваивание значения переменной: `max_value = ...` (выполнение зависит от результата сравнения) 

Таким образом, по завершении цикла счетчик `count` увеличивается на некоторое значение от `2*n` до `3*n`. Итого:

- минимально возможное значение: `count = 2 + 2*n`
- максимально возможное значение: `count = 2 + 3*n`

**Возврат `return max_value`.** На данном этапе выполняется одна простейшая операция – возврат значения из функции. Итого:

- минимально возможное значение: `count = 2 + 2*n + 1 = 2*n + 3`
- максимально возможное значение: `count = 2 + 3*n + 1 = 3*n + 3`

Теперь составим функцию временной эффективности алгоритма `find_max()`. В нашем случае их будет две:

- `k_min(n) = 2*n + 3`
- `k_max(n) = 3*n + 3`

Функция `k_min()` определяет минимальное количество простейших операций, которые будут выполнены внутри алгоритма при размере входных данных `n`. 

Функция `k_max()`, в свою очередь, определяет максимальное количество таких операций.

### Нюансы

Перед тем, как прейти к теоретическому анализу алгоритмов, стоит оговорить две вещи

#### Необходимость точного подсчета простейших операций

**Необходимость точного подсчета простейших операций**

При подсчете простейших операций возникает вопрос о том, насколько точно это следует делать. Например, сколько простейших операций выполняется в программной строке `y = k*x + b`? Можно предположить, что три:

- две арифметические операции (`*` и `+`)
- одна операция присваивания значения переменной

Но в таком случае не учитывается еще одна скрытая операция присваивания результата произведения `k*x` временной переменной перед выполнением операции сложения. 

Таким образом, любая простейшая на вид операция в программе на языке высокого уровня может скрывать десяток других простейших операций, точно определить количество которых достаточно тяжело.

Поэтому разумно проводить **упрощенный анализ**, при котором количество простейших операций определяется **без учета внутренних деталей реализации каждой из них**. 

Более того, упрощенный анализ является единственно возможным способом оценки числа простейших операций, выполняемых внутри алгоритма, поскольку точный их подсчет зачастую практически невозможен.

Отметим, что функции `k_min(n)` и `k_max(n)`, полученные в результате подсчета количества простейших операций, выполняемых внутри алгоритма `find_max()`, были получены именно с помощью упрощенного анализа.

То есть при упрощенном анализе: сколько операторов видим, столько простейших высокоуровневых операций и есть у нас.
#### Анализ лучших, средних и худших показателей

На примере алгоритма `find_max()` видно, что его производительность зависит от входных данных: в одних случаях он выполняется быстрее (совершая меньше операций), а в других – медленнее. 

В теории можно попытаться оценить временную эффективность алгоритма через среднее значение, рассчитанное на основе всех возможных входных данных. Но такой анализ **средних показателей** на практике оказывается слишком сложным.

Поэтому в теории алгоритмов общепринятой оценкой временной эффективности является **худший показатель**, если не оговорено другое условие. 

Например, временная эффективность алгоритма `find_max()` будет выражаться функцией `k_max()`, а не `k_min()` или какой-либо другой. 

Такой подход – анализ худших показателей – значительно проще, поскольку для него требуется лишь определение максимального количества простейших операций, которое может быть выполнено внутри алгоритма (то есть все операции, зависящие от `n` пойдут как `n * k`, где `k` - количество простейших операций высокого уровня).

Что касается **лучшего показателя**, то оценка временной эффективности алгоритма на его основе редко бывает полезной на практике, поскольку в лучшем случае алгоритм может выполнять достаточно малое количество операций и справляться с задачей за секунды, а в худшем – работать дни или даже годы. (Оч смешной пример - алгоритм bogosort)

**Bogosort** — это **неэффективный алгоритм сортировки**, который работает путём случайной перестановки элементов списка до тех пор, пока список не будет отсортирован.

На гистограмме можно видеть графическое выражение времени работы алгоритма в зависимости от количества входных данных (A, B, C, ...)
![[Python алгоритмы (3).png]]

### Примечания

**Примечание 1.** Несмотря на то что временная эффективность алгоритмов описывается с помощью функции от размера входных данных, существуют алгоритмы, время выполнения которых зависит не только от размера входных данных, но и от их **особенностей**.

В качестве примера рассмотрим задачу поиска объекта `x` в списке из `n` элементов. Она решается довольно просто: алгоритм ищет объект `x`, последовательно сравнивая его с каждым элементом списка. Алгоритм завершается, когда объект `x` найден или когда список полностью проверен. В том случае, если объект `x` располагается на первом месте списка, алгоритм завершит поиск сразу **после проверки первого элемента**. Если же объект `x` располагается на последнем месте списка или вовсе отсутствует в списке, алгоритм завершит поиск только **после проверки всех элементов списка**.

**Примечание 2.** В Python (да и в C++ тоже) операторы `+=, -=, *=, ..` выполняют две простейшие операции одновременно: одну арифметическую операцию и одну операцию присваивания значения переменной. Например, приведенные ниже программные строки идентичны в плане количества совершаемых в них простейших операций:

    total += 1
    total = total + 1


