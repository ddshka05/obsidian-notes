### Что такое асимптотическая временная сложность?
В предыдущих уроках мы выяснили, что временную сложность алгоритма можно описать с помощью функции, которая размеру входных данных сопоставляет **максимальное** количество простейших операций, выполняемых внутри алгоритма. 

Помимо этого, мы узнали, что для более простого описания можно использовать не саму функцию, а ее **верхнюю границу**, обозначенную с помощью нотации $O$-большое. 

Такое упрощенное описание временной сложности алгоритма с помощью нотации $O$-большое называется **асимптотической временной сложностью** алгоритма.

***Логичное замечание*:** В литературе и любых других источниках при обозначении верхней границы функции с помощью нотации $O$-большое всегда подразумевается **ближайшая верхняя граница**, если, конечно, не оговорено иное.

### Абстрактные примеры
Например, если количество простейших операций, выполняемых внутри алгоритма, определяется функцией $T(n)=256$, то асимптотическая временная сложность такого алгоритма равна $O(1)$. 

А если количество простейших операций, выполняемых внутри алгоритма, определяется функцией $T(n)=5n+8$, то асимптотическая временная сложность такого алгоритма равна $O(n)$.

***Немного про терминологию***: В теории алгоритмов временная сложность алгоритмов практически всегда описывается с помощью нотации OO-большое. Поэтому временная сложность и асимптотическая временная сложность – это часто **одно и то же**.
### Конкретные примеры
#### Пример 1

```python
def algorithm(data): 
	return (data[0] + data[-1]) / 2
```
 С помощью упрощенного анализа выясним, какой вид имеет функция $T(n)$, определяющая количество простейших операций, выполняемых внутри алгоритма, в зависимости от длины входного списка. Несложно видеть, что искомая функция имеет вид $T(n)=5$, так как алгоритм всегда выполняет ровно пять простейших операций: две операции обращения по индексу (`data[0]` и `data[-1]`), две арифметические операции (`+` и `/`) и одну операцию возврата значения из функции. Определив верхнюю границу функции T(n) получим, что временная сложность алгоритма равна O(1).

По приведенным примерам видно, что временная сложность алгоритма равна O(1) в том случае, если максимальное количество простейших операций, выполняемых внутри алгоритма, **фиксировано и не зависит от размера входных данных**.

Алгоритм из второго примера имеет временную сложность O(1) по той причине, что максимально он выполняет ровно пять простейших операций. Каким бы длинным ни был входной список, больше пяти операций алгоритм не выполнит.

***Важное примечание:***
Размер входных данных алгоритма всегда зависит от характера самих данных. Если алгоритм обрабатывает число, то размером входных данных является величина этого числа, если строку или список – количество элементов в нем.

#### Пример 2
```python
def algorithm(data):
	max_value = data[0] 
	for elem in data: 
		if elem >= max_value: 
			max_value = elem 
	return max_value
```

С помощью упрощенного анализа выясним, какой вид имеет функция T(n), определяющая количество простейших операций, выполняемых внутри алгоритма, в зависимости от длины входного списка. Несложно видеть, что искомая функция имеет вид $T(n)=3n+3$.

Определив верхнюю границу функции T(n), получим, что временная сложность алгоритма равна O(n).

По приведенному примеру видно, что во время определения временной сложности алгоритма, содержащего цикл, выполнять подсчет простейших операций, совершаемых на каждой его итерации, нет необходимости, если количество этих операций **фиксировано и не зависит от размера входных данных**.

Действительно, цикл внутри алгоритма из данного примера совершает n итераций, причем на каждой итерации выполняются максимум три простейшие операции. Таким образом, суммарно цикл выполняет 3n простейших операций. Но поскольку при вычислении временной сложности алгоритма постоянный множитель 3 все равно будет отброшен, то его изначально можно не учитывать и брать в расчет только количество итераций цикла.

Также по приведенному примеру понятно, что во время определения временной сложности алгоритма, чья сложность заведомо больше, чем O(1), нет необходимости выполнять подсчет тех простейших операций, чье количество **фиксировано и не зависит от размера входных данных**.

Так, например, три дополнительные простейшие операции (`data[0], max_value = data[0]` и `return max_value`), которые совершает алгоритм из данного примера, можно не учитывать, поскольку при вычислении временной сложности алгоритма все постоянные слагаемые все равно будут отброшены.

***Вывод:*** Если алгоритм обрабатывает список из n элементов и при этом просматривает все элементы этого списка, то временная сложность такого алгоритма равна минимум O(n).

#### Пример 3

```python
def algorithm(data):
	max_value = data[0] 
	index = 0
	while index < len(data): 
		elem = data[index] 
		if elem >= max_value: 
			max_value = elem 
		index += 1 
	return max_value
```

Алгоритм содержит цикл, который совершает nn итераций, где nn – длина входного списка. На каждой итерации цикл выполняет фиксированное количество простейших операций, независимо от размера входных данных, поэтому эти операции можно не учитывать и в расчет брать только количество итераций цикла. Таким образом, учитывая только количество итераций цикла, равное nn, получим, что временная сложность алгоритма равна O(n).

***Замечание:***
Неважно, какой тип цикла используется внутри алгоритма: `for` или `while`. Важно лишь то, сколько итераций совершает этот цикл и какое количество простейших операций выполняется на каждой его итерации.
### Примечания
[[Работа функции len() в Python]]
