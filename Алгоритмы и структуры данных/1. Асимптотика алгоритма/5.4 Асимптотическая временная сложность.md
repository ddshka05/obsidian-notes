## Алгоритмы с вложенными циклами
**Пример.** Определим временную сложность некоторого алгоритма для обработки целого числа:

```python
def algorithm(n): 
	total = 0
	for i in range(n): 
		total = total + i 
		for j in range(n): 
			total = total + j 
	return total
```

Алгоритм содержит цикл, внутри которого находится другой цикл. У нас нет какого-либо правила работы с вложенными циклами, поэтому для определения временной сложности алгоритма выполним подсчет максимального количества простейших операций, совершаемых внутри алгоритма.

Заметим, что находящийся внутри алгоритма цикл (`for i in range(n)`) совершает n итераций, где n – величина входного числа. Наличие этого цикла говорит о том, что временная сложность алгоритма равна как минимум $O(n)$. Поэтому мы сразу можем исключить из подсчета те простейшие операции, которые всегда выполняются одно и то же количество раз, независимо от размера входных данных. К таким операциям относятся одна операция присваивания значения переменной (`total = 0`) и одна операция возврата значения из функции (`return total`).

Теперь посчитаем, сколько простейших операций выполняет оставшаяся конструкция из двух циклов: внешнего (`for i in range(n)`) и внутреннего (`for j in range(n)`). 

Как было замечено ранее, внешний цикл совершает n итераций. При этом на каждой его итерации выполняются:

    for i in range(n)    # одна операция присваивания значения переменной i
    total + i            # одна операция сложения двух чисел
    total = total + i    # одна операция присваивания значения переменной total
    for j in range(n)    # n операций присваивания значения переменной j
    total + j            # n операций сложения двух чисел
    total = total + j    # n операций присваивания значения переменной total

Всего на каждой итерации внешнего цикла выполняется $3n+3$ простейших операций. Тогда суммарно вся конструкция из двух циклов выполняет $n⋅(3n+3)=3n^2+3n$ простейших операций. Из этого следует, что временная сложность алгоритма равна $O(n^2)$.

**Пример.**

```python
def algorithm(n): 
	count = 0 
	for _ in range(4 * n): 
		j = 1
		while j < n: 
		j = j * 2 
		count = count + 1 
	return count
```

Алгоритм содержит цикл, внутри которого находится другой цикл. Внешний цикл совершает $4n$  итераций. На каждой итерации внешнего цикла внутренний цикл совершает  $\lceil\log⁡_{2}{n}\rceil$ итераций. Так как во внешнем и внутреннем циклах нет простейших операций, количество которых зависит от размера входных данных, при определении временной сложности алгоритма достаточно учитывать только то, чему равняется произведение количества итераций внешнего и внутреннего циклов. Оно равняется $4n$ ⋅ $\lceil\log⁡_{2}{n}\rceil$, поэтому временной сложностью алгоритма является $O(n\log{⁡n})$.

**Пример.** Определим временную сложность некоторого алгоритма для обработки целого числа:

```python
def algorithm(n): 
	count = 0 i = 1 
	while i < n: 
		j = 1 
		while j < n: 
			j = j * 3 
			count = count + 1 
		i = i * 2 
	return count
```

Алгоритм содержит цикл, внутри которого находится другой цикл. Внешний цикл совершает $\lceil\log⁡_{2}{n}\rceil$ итераций. На каждой итерации внешнего цикла внутренний цикл совершает $\lceil\log⁡_{3}{n}\rceil$ итераций. Так как во внешнем и внутреннем циклах нет простейших операций, количество которых зависит от размера входных данных, при определении временной сложности алгоритма достаточно учитывать только то, чему равняется произведение количества итераций внешнего и внутреннего циклов. Оно равняется $\lceil\log⁡_{2}{n}\rceil$$\cdot\lceil\log⁡_{3}{n}\rceil$, поэтому временной сложностью алгоритма является $O((\log{n}) ^ 2).$
### Правила определения асимптотики для вложенных циклов
Если на каждой итерации **внешнего цикла** выполняются простейшие операции, количество которых **фиксировано и не зависит от размера входных данных** (к примеру, две операции присваивания значения переменной), то эти операции можно не учитывать.

Если на каждой итерации **внутреннего цикла** выполняются простейшие операции, количество которых **фиксировано и не зависит от размера входных данных**, то эти операции также можно не учитывать.

Таким образом, если во внешнем и внутреннем циклах нет операций, количество которых зависит от размера входных данных (конечно, не учитывая наличие внутреннего цикла в теле внешнего цикла), то при определении временной сложности алгоритма достаточно учитывать только то, чему равняется **произведение количества итераций внешнего и внутреннего циклов**.

Также если алгоритм содержит цикл, внутри которого находится другой цикл, то правило, при котором временная сложность алгоритма оценивается лишь произведением количества итераций внешнего и внутреннего циклов, совершенно справедливо **для любой пары циклов**.

На самом деле правило умножения количества итераций каждого цикла справедливо и **для трех циклов, и для любого их количества**. Так, если алгоритм содержит цикл, внутри которого находится другой цикл, а внутри него – еще один, и так любое количество раз, то при определении временной сложности алгоритма достаточно учитывать только то, чему равняется **произведение количества итераций всех этих циклов** (конечно, при условии, что ни в одном из циклов нет простейших операций, количество которых зависит от размера входных данных).



