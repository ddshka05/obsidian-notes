## Сбор информации

- Прочитайте внимательно условие задачи.
- Поймите проблему.
- Перескажите своими словами
- Какие данные у вас есть?
- Что нужно найти?
- Какие ограничения?
- Нарисуйте проблему
- Нужно ли найти ещё данные?
- Уточняйте. Так много и часто, как возможно, пока не наступит момент, что вопросов больше нет. (Как? Почему? Где? Зачем? А здесь? Что, если?)
- Ищите примеры (простые, сложнее, сложные)
- Где применяется?
- Что решает проблема?
- Кто связан с ней?
- Можно ли менять условия?
- Чего мы не знаем?
- Валидные ли условия?
- Нет ли противоречий?
- Разделите условия на составные части
## Работайте над гипотезами

- Какие подобные проблемы мы уже решали?  Попробовать увидеть паттерн, дать поработать интуиции, а потом ее проверить
- Какие проблемы мы видели, но в другой форме?
- Переберите все возможные техники и алгоритмы, которые знаете
- Посмотрите на проблему с разных углов, точек зрения, областей.
- Декомпозиция. Может проблема состоит из комбинации других? Попробовать выделить подпроблемы насколько это возможно. Они должны быть проще, чем текущая. Они также разбиваются на более простые подпроблемы и тд, пока не наступит этап, когда каждая из маленьких проблем имеет решение. 
- Решаем в лоб самым тупым способом - brute force. Есть ли медленное решение, на котором можно проверить более быстрое? Переберем все значения. Может дать большее понимание задачи и уверенность, что какое-то решение уже есть.
- Нарисуйте на бумаге варианты идей
- Попытка угадать алгоритм, как черный ящик, используя гипотезу - “А что, если оно вот так работает?” (неизвестно, как именно досконально, но поведение и результат вот такой). Потом начинаем ее проверять - прямолинейно или в обратном порядке, или от противного (если бы она не работала, то у нас была бы такая ситуация, при которой такие-то данные, условия, действия и тд, решим когда все плохо и потом посмотрим, что останется для ситуации, когда все хорошо).
- Уберите все невозможные варианты из решения. Запишите их отдельно. Иногда, самое невозможное и есть путь к решению.
- Найди все corner (extreme) cases вашей проблемы. Попробуйте решить проблему для них. Возможно, это даст понимание, решение или путь к нему.
- Используйте инверсию (Что, если все наоборот? Как сделать так, чтобы такие условия точно не сработали? Как сделать наоборот хуже? Если я хочу помочь Индии, то какие есть способы, чтобы навредить Индии?). Этот способ очень любил Charlie Munger.
- Используйте backwards thinking. Думаем не вперед, как в проблеме, а назад. Как-будто все действия уже случились и наше конечное состояние на самом деле начальное, а начальное конечное. Мы идем не вперед, а назад и пытаемся найти закономерности или идеи.
- Решите самую простую версию по данным. Все числа равны нулю, только один или два элемента, ноль элементов, только одна-две вершины в графе, только одна строка в матрице и тд.
- Решите самую простую версию по условиям. Уберите все условия и ограничения. Можно ли решить задачу теперь?
- Измените упрощенную версию. Постепенно добавляйте в упрощенную версию больше значений, параметров или условий. Приближает ли к решению?
- Представьте ситуацию, когда все условия соблюдены.
- Найдите такую упрощенную версию, которая может быть сведена к более сложной текущей версии, но которую можно решить.
- Рассмотрите более сложную версию (парадоксально, но может помочь).
- Изменить условия. Пробовать решить за O(n), O(nlogn), O(n^2), O(n^3) и т.д.
- Возможно для решения уже есть формула. Последовательности и тп.
- Сколько состояний у нас есть? Что меняется в процессе работы алгоритма? Что остается неизменным?
- Моделируйте, добавляя новые и убирая текущие свойства проблемы.
- Представьте, что решение уже готово. Можем ли мы как-то это использовать? Разложить еще на составляющее и тд? Выделите его в функцию или объект, который вернет нужный ответ или частичный ответ. Или использовать, как заглушку (Get Filtered Items - как-то там вернет то, что нам надо для решения).
- Итеративное мышление. (Быстро и жадно, сохраняя какой-то инвариант и накапливая решение).
- Декларативное решение, рекурсия, divide and conquer. (Более емко, нет изменяемых данных и т.д.). Пусть задача решена для текущего случая или отрезка - как нам перейти в следующее состояние? Пусть задача решена для левого и правого отрезка - как нам их объединить в текущем отрезке?
- Используйте аналогию (аналогичная проблема, которую решили раньше).
- Используйте ассоциативное мышление (Найти какие-то связанные задачи, объединяя с текущей по какой-то идее, признаку или свойству).
- Используйте индукцию (Выведите общее решение из наблюдения и комбинации простых вариантов решения и частных случаев).
- Решите частные случаи. Specialization.
- Решите в общем виде. Generalization (generic решение для всех похожих проблем). Для этого нужно искать закономерности и паттерны. Чем все частные решения похожи, что можно выделить в общее? Теперь общее может принимать и обрабатывать любые частные случаи.
- Inventor's paradox. Чтобы решить частную проблему, мы можем попытаться быть намного более амбициозными и решить намного более сложную или общую проблему, больше, чем текущая. И решение текущей будет получено из данного решения. Общее решение может иметь проще алгоритм и более чистый дизайн, и занимать меньше времени для решения.
- Можно ли изменить данные?
- Можно ли рекомбинировать проблему и элементы? Поставить их иначе, разный порядок, рисунок, паттерн и тд.
- Можно ли трансформировать проблему? Измените вашу проблему так, чтобы создать новую проблему, решение которой поможет вам найти решение текущей.
- Можно ли трансформировать похожую проблему?
- Вернуться назад и проверить, все ли мы использовали из условий?
- Визуализируйте. Представьте, как оно работает. Оживите вещи в задаче. Посмотрите на них мысленным взором. Манипулируйте ими в вашем воображении.
- Важен ли порядок? Если нет, мы можем переставлять, сортировать, как нам удобно. Какой алгоритм можно применить, если числа сортированы? Что, если они в определенном порядке?
- Какие есть инварианты? То, что всегда должно быть валидно после каждой итерации? То, что можно поддерживать в ходе алгоритма в валидном состоянии и использовать для получения следующего частичного или полного ответа. Что ведет нас к ответу.
- Гуглите идеи.
- Спрашивайте у других.
- Найдите похожую проблему или отдаленно похожую и решите ее (Атакуйте все проблемы вокруг, пытаясь приблизиться к данной).
- Придумайте похожую проблему, если не помните ни одной.
- Какая связь между данными и неизвестным?
- Brainstorming. Генерируйте идеи. Любой кринж, уникальность или неочевидность.
- Reduction to an absurdity. Если это было бы так, то свиньи умели бы летать. Если земля была бы плоской, у нее был бы край и с него можно было бы упасть. Мы берем утверждение и развиваем его, доводя до абсурда - ложного или невозможного заключения, которое нивелирует изначальное утверждение.
- Proof by contradiction. Делаем отрицание исходного утверждения и доказываем его. Если оно приводит к противоречию с исходным утверждением, значит исходное была правдой. Если свойства объекта существуют, то докажем, что ни у какого объекта их не существует.
- Создайте всевозможные тестовые данные для проверки.
- Используйте автоматические fuzzy тесты.
- Фиксируйте промежуточные решения тестами и отдельными блоками. Сохраните себе то, что точно работает.
- Перечитать условия еще раз.
- Используйте симметрию. Попробуйте найти симметричные детали. Нарисовать вторую половину, какой она могла бы быть и тд.
- Рассмотреть разные области знаний. Искать взаимосвязи между разными науками, областями, разделами. Искать связи между несвязанными вещами.
- Попробовать смоделировать - отбросить составные части, которыми можно пожертвовать для того, чтобы модель реального мира была проще и доступней на бумаге.
- Отложить задачу на потом и сменить контекст. Вернуться позже сегодня или завтра-послезавтра. Поделать что-то не связанное с этой задачей или вообще этой деятельностью.
## Пробуйте каждую гипотезу
- Одну за один подход.
- Нужно вовремя понять, если она не работает.
- Не бояться оставить ее, если она не работает и искать другую.
- Фиксируйте этапы письменно.
- Попробуй подумать, может не надо хранить некоторую информацию о данных, может сумма, произведение или другое будет хранить нужную информацию для работы алгоритма?
- Если нужно, be agile, и откатитесь на пару этапов назад.
- Не долбитесь головой об стену, если нет прогресса.
## Обдумайте решение

- Как у вас получилось решить проблему?
- Как еще можно решить?
- Где можно применить в будущем?
- Какие есть похожие проблемы?
- Как можно было сделать это лучше?
- Как можно сделать красивее?
- Проверьте каждый шаг.
- Что мешало вам решить проблему?
- Как избежать этих помех в будущем?
- Как делать это быстрее в будущем?
- О чем вы думали?
- Что вас отвлекало?
- Мы нашли новый паттерн? Стоит запомнить?