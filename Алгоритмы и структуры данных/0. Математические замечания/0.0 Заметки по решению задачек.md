### Общие практики
1. Иногда не нужно хранить всю информацию о входных данных, иногда достаточно суммы, количества и т.п.
2. Во время придумки гипотезы стоит продумать условия для ветвления или иные условия. которые влияют на ход решения программы
3. Осторожнее относиться к целочисленному делению, иногда оно, с точки зрения математики, выдает неправильные ответы. Например:
```python
def number_of_handshakes(n):
    return n // 2 * (n - 1)
# и этот код
def number_of_handshakes(n):
    return (n * (n - 1)) // 2 
# возвращают разные значение при n = 3.
```
3. При проходе по подспискам или подмассивам и иным коллекциям для проверки условий, чтобы не проверять на входе и внутри вложенного цикла, можно делать вот так (то есть начинать j-ый цикл с i-го значения индекса)
```python
def find_sum_indexes(nums, value):
    n = len(nums)

    for start in range(n):
        current_sum = 0

        for end in range(start, n):
            current_sum += nums[end]
            if current_sum == value:
                return (start, end)
            if current_sum > value:
                break
    return -1
```
4. Прикольно, что можно проверить последний и первый элемент коллекции и на этом построить алгоритм (если мы например говорим про [тип последовательностей](https://stepik.org/lesson/1403189/step/5?auth=login&unit=1420151))
5. Можно так же чуть-чуть изменить условие задания, сохраняя логику, чтобы проверить все разом, например. Нужно одновременно сравнивать возраст, в поисках максимального, и имя, в поисках лексически минимального. Это можно выполнять одновременно, изменив знак возраста в ключевой функции в `min()` - ищем минимальные "отрицательный возраст" и имя.

```python
def get_oldest(ages):
    return min(ages.items(), key=lambda a: (-a[1], a[0]))[0]
```

6. В задачах про максимум, наверное лучше выставлять бесконечности вместо чисел в коллекции, более общая практика наверное, иногда этот способ подходит лучше. 
7. Чтобы краевые решения тоже проверялись, можно поменять логику программы (проверять другое условие на ветвлении).
```python
def max_consecutive_ones(nums):
    n = len(nums)
    max_count = 0

    cur_count = 0
    for i in range(n):
        if nums[i] == 1:
            cur_count += 1
            max_count = max(cur_count, max_count)
        else:
            cur_count = 0
            
    return max_count
```

Вместо того, что выше, лучше выглядит это:
```python
def max_consecutive_ones(nums):
    max_count = 0
    current_count = 0

    for num in nums:
        if num == 0:
            current_count = 0
        else:
            current_count += 1
            max_count = max(current_count, max_count)

    return max_count
```

То есть поменяли условие на проверку и получили, что как будто код выглядит лучше, и читается проще, а также захватывает все краевые решения!
### Использование коллекций для решение задач
1. Словари - это круто). Можно в них зашить условие, которые потом можно проверять)
### Полезные паттерны в алгоритмах, которые никак не называются
1. **"Семафорная азбука"** **или** **"однопроходная проверка согласованности"**

Это можно назвать и как **"однопроходная проверка согласованности"** , потому что  за один проход по массивам определяем, соответствует ли поведение ответов одному из двух допустимых шаблонов: _все правильные_ или _все неправильные_, все больше или меньше друг друга и так далее. 

Мы создаем два флага, и на каждой итерации другой флаг не должен поменять значения, если это так, то возвращается False или иное условие по задаче.

```python
def is_perfect_possible(key, answers):
    found_correct = False # наши флаги
    found_incorrect = False # наши флаги
    for k, a in zip(key, answers):
        if k == '*':
            continue
        if k != a:
            found_incorrect = True
            if found_correct: # если флаг тоже True, то возвращаем False
                return False
        else:
            found_correct = True
            if found_incorrect: # если флаг тоже True, то возвращаем False
                return False
    return True
```


2. Волновой паттерн (wave pattern)
Используется в подготовке к собеседованиям. Также можно решить им такие задачи:

а) **Оптимизация выбора "победителей" в сравнениях**
Представь, что ты хочешь выбрать участников так, чтобы каждый следующий был "слабее", но через одного — "сильнее". Это может использоваться в:

- **Соревнованиях** или **ранжировании игроков**
- **Рейтинговых системах** , где важно создать чередование результатов

Например, если у тебя есть отсортированный список игроков по силе, можно сделать волну так, чтобы более слабый игрок стоял между двумя сильными — это создаёт эффект «баланса».

б) **Визуализация данных**
Если тебе нужно красиво показать данные в виде графика, волновой порядок может помочь избежать резких скачков вверх-вниз.

в) **Алгоритмы жадного типа**
Волна может быть частью более крупной задачи, где требуется удовлетворить набор **локальных ограничений** .

Например:
- Жадная перестановка для минимизации количества операций
- Перестановка элементов под определённый шаблон (например, в задачах на LeetCode)

г) **Игровые и стратегические алгоритмы**
В играх, где важна стратегия выбора ходов, волновой порядок может использоваться для:
- Сравнения эффективности ходов
- Создания баланса между игроками или действиями