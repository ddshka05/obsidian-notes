На этом занятии речь пойдет о функции printf(), с которой нам ранее уже приходилось сталкиваться, начиная с самой первой программы. Как я отмечал, название функции – это сокращение от английских слов:

`print formatted (форматированный вывод)`

А само определение (прототип) функции следующее:

`int printf(const char* format, …);`

Первый параметр format – это указатель на строку. Пока его можно воспринимать просто как строку, в которой определен формат для вывода информации в стандартный поток stdout. А троеточие определяет произвольное число дополнительных параметров. 

Обычно, это переменные или выражения, значения которых следует выводить в заданном формате. В качестве возвращаемого типа указан int, то есть функция возвращает целое число. Это число соответствует количеству выведенных символов в стандартный поток stdout (в нашем случае на экран). Обычно, на практике, этим значением пренебрегают и вызывают функцию printf(), как говорят, **ради побочного эффекта**, т.е. ради передачи данных в выходной поток.

В самом простом варианте мы с вами использовали эту функцию для вывода строки на экран:

```C
#include <stdio.h>
 
int main(void)
{
    printf("Hello, World!\n");
    return 0;
}
```

Но, как вы уже догадались, функция printf() способна на гораздо большее! На этом занятии мы рассмотрим лишь основные ее возможности, которые наиболее часто применяются на практике. Если вам понадобится больше информации, то справочные руководства всегда к вашим услугам.

Итак, первый параметр format функции printf() определяет не просто выводимую строку, а формат выдаваемых данных. И для этого в нашем распоряжении имеются, так называемые, **спецификаторы преобразования**. Основные из них следующие.
### Спецификаторы перобразования printf()

![[Pasted image 20250712152343.png]]

Итак, давайте посмотрим, как можно воспользоваться этими спецификаторами преобразования. Пусть у нас в программе определена целочисленная переменная var_i с начальным значением 1208:

``` c
int var_i = 1208;
```

И мы бы хотели вывести ее значение на экран в виде десятичного числа с помощью функции printf(). Из таблицы видим, что для этого подходит спецификатор %d. Им и воспользуемся, следующим образом:

```c
printf("value = %d\n", var_i);
```

После запуска программы на экран будет выведено:

```
value = 1208;
```

Почему так и как это работает? Сморите, вначале функция printf() выполняет анализ форматной строки. В некотором смысле она работает как ее интерпретатор. Как только в строке встречается символ %, скорее всего, это некоторый спецификатор. И, действительно, дальше идет символ d, функция «понимает», что это спецификатор %d, на место которого нужно подставить значение переменной в виде целого десятичного числа со знаком (если он есть; знак + не ставится). При этом берется первая переменная, записанная после форматной строки. В нашем случае – это var_i со значением 1208. В результате получаем итоговую строку «value = 1208».

А теперь, давайте, вместо спецификатора %d запишем, например, спецификатор %x:

```c
printf("value = %x\n", var_i);
```
В результате будет выведена строка:

```
value = 4b8
```

То есть, спецификатор %x преобразовывает данные из переменной var_i в шестнадцатеричный формат и подставляет на свое место. И так работает каждый спецификатор. Даже если прописать:

```C
printf("value = %f\n", var_i);
```

для вывода значение переменной var_i как вещественное число, то ошибки никакой не будет, но отображаемое значение будет, конечно же, некорректным:

```
value = 0.000000
```

Но, если изменить тип переменной var_i на вещественный:

```c
double var_i = 1208;
```

то увидим правильное значение:

```
value = 1208.000000
```
## Суффиксы типов для спецификаторов
### Про целые числа
Этот пример показывает, что спецификаторы должны быть согласованы с типами данных переменных или выражений. Причем, целочисленные типы char и short, при передаче значений функции printf(), автоматически приводятся к типу int. Поэтому спецификатор %d охватывает все три типа: char, short, int. Если же переменная имеет тип long или long long, то перед спецификаторами допустимо прописывать малые буквы l и ll соответственно:

- l – суффикс для типов long или unsigned long;
- ll – суффикс для типов long long или unsigned long long.

Так как в моей версии компилятора типы long и int по размеру совпадают и имеют 4 байта (32 бита), то приведу пример с типом long long, который занимает 8 байтов (64 бита):

```c
printf("value = %lld\n", -12345678901234LL);
printf("value = %llu\n", 12345678901234LL);
```

Если при выводе в спецификаторах убрать буквы ll, то значение будет отображено некорректно:

```c
printf("value = %d\n", -12345678901234LL);
```

Увидим:

```
value = -1942892530
```
### Про вещественные числа
Аналогично и с вещественными типами: float автоматически преобразовывается в double, поэтому спецификаторы %f, %F, %e и %E корректно обрабатывают оба из них. А вот для типа long double следует прописывать суффикс в виде заглавной буквы L:

- L – суффикс для типа long double.

Например:

```c
long double var_ld = 0.5;
printf("value = %Lf\n", var_ld);
```

Увидим строку:

```
value = 0.500000
```

Но, при использовании спецификатора без суффикса L, вывод окажется некорректным:

```c
printf("value = %f\n", var_ld);
```

На выходе:

```
value = -0.000000
```

Так с помощью суффиксов учитываются все базовые типы переменных языка Си.
## Вывод нескольких переменных
Конечно, с помощью функции printf() можно выводить сразу несколько переменных в одной форматной строке. Делается это очевидным образом. Достаточно указать нужное количество спецификаторов, а затем, перечислить такое же количество переменных или выражений.
## Флаги спецификаторов
Каждый спецификатор может быть дополнительно снабжен, так называемыми, флагами, которые предоставляют возможность более тонкой настройки выводимой информации. Ниже в таблице приведены основные из них.

![[Pasted image 20250712153659.png]]

Давайте посмотрим на конкретных примерах, как можно использовать эти флаги по отдельности и в комбинации с другими флагами. Объявим в программе две переменные var_i и var_d с некоторыми начальными значениями, а затем выведем их в столбик с шириной поля 10:
```c
printf("%10d\n", var_i);
printf("%10f\n", var_d);
```

Если указанная ширина поля будет меньше размера выводимых данных, то она автоматически будет увеличена до нужных размеров.

Если вместо целого числа указывать дробное, то в случае с целыми числами число до точки (12) будет задавать общую ширину вывода, а число после точки (7) – ширину отображаемых данных, которая дополняется нулями:

```c
printf("[%12.7d]\n", var_i);
printf("[%12.2f]\n", var_d);

// или как ниже

printf("[%.7d]\n", var_i);
printf("[%.2f]\n", var_d);
```

В случае с вещественными числами, значение 12 определяет общую минимальную ширину вывода, а число после точки (2 и 7) – точность выводимого значения. После запуска программы увидим:

И так далее.


