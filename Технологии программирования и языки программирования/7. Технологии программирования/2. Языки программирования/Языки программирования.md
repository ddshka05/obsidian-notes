### Парадигмы программирования

-  **Императивное**
	 Императивное программирование отвечает на вопрос "Как?"
	 В коде находятся в инструкцию, которые выполняются последовательно. Данные, которые выдали предыдущие инструкции, могут быть считаны следующими. Эти данные записываются в память. 
	 Ex: С/С++, Java, Python and etc.
- **Декларативное**
	 Декларативное программирование отвечает на вопрос: "Что?" (что должно быть сделано, чтобы был нужный результат). То есть не важно, каким образом будет достигнут результат, перечисляются свойства результата.

### Категоризация императивных языков программирования
- Процедурное программирование (код пишется, с помощью функций)
- Структурное программирование (код пишется при помощи структур)
- Аспектно-ориентированное программирование (нацелено на реакцию на аспект)
- ООП (инкапсуляция, полиморфизм, наследование)
- Обобщённое программирование (объединяет парадигмы)

### Категоризация декларативных языков
В категоризации обычно закладываются языки, которые находятся в парадигме функционального программирования
**Функциональное программирование:**
- Haskell (все объекты иммутабельные, нельзя присваивать переменные)
- F# 
- LISP
**Логическое программирования:**
	 Когда думали, что ИИ будет выглядеть не как ГПТ чат, считалось, что ИИ будет быстро перебирать все возможные варианты логически и сможет выдавать результат, так появилось логическое программирование и язык Prolog. Задается множество правил, которые должны выполняться. 
- Prolog - мертворожденный язык, применяется кулуарно.

### Метапрограммирование
Это когда программы генерируют программы (например в С++ - шаблоны) - не про чат ГПТ

### Реактивное программирование
Изменили данные на входу -> изменяются результаты на выходе. Примеры: Excel (изменив одну ячейку меняется весь результат протяжки формулы, зависящий от этой изменённой ячейки), Rx-либы.

С помощью него так же реализуются некоторые [[Паттерны проектирования]] - например [[Observer]].

### Событийное программирование
Необходимо создать ивент (событие). И хотелось бы, чтобы в поточном режиме выполнялось какая-то функция

То есть мы можем создавать потоки, которые будут выполнять задачи, параллельно с другими потоками. А также можем получать решение функций в этих потоках (через callback).

Есть один антипаттерн проектирования - [[Callback Hell]], связанные с этими возможностями

При использовании асинхронных функций, количество потоков может быть увеличено. Для регуляции этого существует сущность event (событие).

##### Виды событий:
- Системные события - приходят из ядра ОС
- Пользовательские события - создаются пользователями 

Реализуется это через паттерн (См.: [[Паттерны проектирования]]) под названием [[Event Loop]]. 

### Реактивное программирование VS Событийное программирование

Реактивное - изменение данных
Событийное - создание событий