### Почему архитектура x86_64 стала популярна и разветвление её
Компьютер IBM PC, выпущенный в 1981 году, оснащался процессором Intel 8088, а более поздние модели — процессорами 80286, 80386 и 80486, поэтому ISA стала известна как x86.

В этом тысячелетии компания AMD расширила x86 для поддержки 64-битных чисел, и результат сначала назывался x86_64, а потом [разными другими словами](https://ru.wikipedia.org/wiki/X86-64#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5_%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F). Intel кстати делал свою такую архитектуру, Itanium и собиралась продавать для серверов. Но она не взлетела, они просто расширили эту архитектуру (Intel 64)

У этой архитектуры до жопы проблем, но она все равно популярная!
### Машинный код и язык ассемблера
Рассмотрим для примера реализацию алгоритма Евклида для 32-битных чисел на x86:

`39 c8 74 07 77 01 91 29 c8 eb f5`

Правило интерпретации определены самой архитектуры. Имеются двухбайтовые инструкции.

Допустим, она расположена в памяти начиная с адреса 0x43210, и IP (instruction pointer) процессора равен 0x43210. Посмотрим, что будут значить для процессора эти байты:

![[Pasted image 20250701141859.png]]

Это ужас, поэтому для инструкций придумывают названия (мнемоники) и правила записи их операндов, а потом делают **конвертор** из такого текстового представления в двоичное (машинный код).

Такой конвертор называется ассемблером, а текстовое представление инструкций — языком ассемблера. Вот так будет выглядеть наш код, если его писать на ассемблере.

```
43210:       39 c8     cmp eax, ecx     // сравнить регистры 0 и 1
43212:       74 07     je 0x4321b       // если числа равны, прибавить к IP                                                число 0x07 = 7
43214:       77 01     ja 0x43217       // если первое число больше, прибавить                                             к IP число 0x01=1
43216:       91        xchg eax, ecx    // поменять местами регистры 0 и 1
43217:       29 c8     sub eax, ecx     // вычесть регистр 1 из регистра 0
43219:       eb f5     jmp 0x43210      // прибавить к IP число 0xf5 = −9
4321b:       ...
```

В мире x86 исторически больше всего используются два синтаксиса языка ассемблера: AT&T vs Intel. Эти же инструкции в синтаксисе AT&T (В среде GNU чаще используется) выглядят так:

```
cmp    %ecx,%eax
je     ...
ja     ...
xchg   %eax,%ecx
sub    %ecx,%eax
jmp    ...
```
### Регистры
Регистры - это ячейки памяти внутри процессора.

![[Pasted image 20250701143819.png]]

Первая картинка, это схема, которую мы ранее рисовали. А справа - картинка уже больше похожая на реальность. 

На ней видно, что внутри процессора уже не просто один IP хранится, но ещё и какие-то другие переменные. Также память не монолитна, а делаться на кэш (кэши) и оперативную память.
#### Как в asm представлять регистры и правила работы с ними.
**Далее представлена мнемоника от Intel**

IP мнемонически записывается так: 
Instruction pointer (program counter): `rip`. (все регистры начинаются с `r` - `register`) - то есть адрес следующего байта, с которого мы начнём декодировать инструкцию.

IP - это регистр специальный, поэтому туда нельзя положить другие как-то данные.

Есть также регистры общего назначения (general purpose registers). Первые регистры имеют исторические названия (представим этот набор регистров в регистровом файле):

![[Pasted image 20250701144545.png]]

Регистровый файл - это файл, в котором собран весь набор регистров.

В 32 битных процессорах Intel было 8 регистров общего назначения, они перечислены во второй колонке. Они были 32 битные. 

Кстати, к некотором регистрам все так же можно обращаться по старому (rax = eax = ax = ah, al (high, low)). Причем, например, ah и al имеют 1 байт, ax имеет 2 байта, eax имеет 4 байт, rax имеет 8 байт. (но обращаться можем все так же). 

Это было сделано для совместимости, чтобы так же можно было обращаться к предыдущим названиям регистров 

Регистры `*sp` имеют специальное значение, мы их пока не трогаем.
### Первые инструкции
Инструкция `move` выглядит примерно так: `мнемоника операнд-приемник, операнд-источник`.

Наша первая мнемоника: `mov`. Это копирование данных в источнике и положить в приемник:

```intel_style_asm
mov DeSinaTion, SouRCe    // копировать SRC в DST

mov ebx, eax   // скопировать биты eax в ebx
               // и выставить старшие 32-го бита rbx в 0;
               // старое значение rbx теряется

mov ax, bx
mov ah, bl

mov rdi, rsi
```

Когда мы работаем с регистрами по памяти до 16, то мы меняем только их. 

Инструкции над 32-битными регистрами же обнуляют верхнюю часть 64-битного регистра. 

```intel_style_asm
mov rcx, 42   // положить в rcx битовое представление числа 42

mov rdx, 0x80 // шестнадцатеричная запись операнда
mov eax, -1   // установить все биты eax в 1 (а старшие биты rax в 0)
```
### Арифметические инструкции
```
add DST, SRC  // DST += SRC
sub DST, SRC  // DST -= SRC
inc DST       // DST++
dec DST       // DST--
neg DST       // DST = -DST
not DST       // DST = ~DST
and DST, SRC  // DST &= SRC
or  DST, SRC  // DST |= SRC
xor DST, SRC  // DST ^= SRC
```

### Первая программа на asm
Нам так же понадобится библиотека `simpleio` для записи и считывания числа.
```
call writei32   // напечатать на экране значение edi
                // как знаковое десятичное число
call writei64   // вывести rdi 
call readi32    // ввести с клавиатуры число и сохранить в eax
call readi64    // ввести с клавиатуры число и сохранить в rax
call finish     // завершить исполнение программы
```

Любой вызов подпрограммы сохраняет значения регистров `rbx, rsp, rbp, r12–r15`. Остальные регистры могут измениться произвольным образом. Мы пока ограничены этими подпрограммами.


```asm
	.intel_syntax noprefix // переключаем синтаксис в режим Intel
    .global main     // эта программа экспортирует символ main 
main:                // метка main - запомни по какому адресу                                  записываешь инструкции и сохрани адрес в эту                           метку
    call readi64     // считали первое число
    mov r12, rax     // сохранили его в r12, чтобы прочитать следующее
    call readi64     // считали второе число
    add r12, rax     // сложили первое и второе
    mov rdi, r12     // так как следующая инструкция ожидает значение                          в rdi, то скопируем туда
    call writei64    // вывели результат
    call finish      // завершили программу
```

Нужно завершить программу и написать `finish`. (иначе можем получить `illegal instruction`)

Ассемблер эту программу оттранслирует в машинный код, далее положит её в память, процессор сможет прочитать наши инструкции.

Сохраним её в файл `sum.S` (да, заглавная S), оттранслируем и запустим:
```bash
$ gcc sum.S simpleio_x86_64.S -o sum
$ ./sum
	```
### Инструкции сдвига
Логический сдвиг: двигаем биты внутри регистра, дополняя его нулями и теряя то, что «выпало».

```asm
mov ax, 0x1234   // положили 2 байта
shr ax, 4        // ax == 0x0123 - добавили                       слева
shl ax, 4        // ax == 0x1230 - добавили                       справа
add ax, 7        // ax == 0x1237
ror ax, 4        // ax == 0x7123 - сдвиг по                       циклу справа
rol ax, 4        // ax == 0x1237 - сдвиг по                       циклу слева
```

Арифметический сдвиг вправо: двигаем биты, дополняя слева знаковым битом (то есть либо 0 либо 1). Это сделано для сохранения отрицательности числа.  

```
mov ax, 0xfff0   // ax == -16
sar ax, 4        // ax == 0xffff == -1
sal ax, 5        // ax == 0xfff0 == -16

mov ax, 0x0123   // ax == 0x0123
sar ax, 4        // ax == 0x0012
```

