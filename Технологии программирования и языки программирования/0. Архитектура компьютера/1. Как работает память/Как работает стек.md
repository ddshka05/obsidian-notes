### База
Вcя оперативная память делится на стек (stack) и куча (heap). 

**Стек** - это специально отведённая область оперативной памяти для хранения временных данных. Благодаря ему существует возможность вызывать подпрограммы (функции). По другому его ещё называют *аппаратный стек*.

**Куча** - это область памяти, которая устроена так же, как и было описано в базовом видео про память. В этой области находятся все работающие программы, включая ОС.

Все данные в куче располагаются линейно слева направо по мере роста адресов. В куче же идет рост в обратную сторону, то есть рост адресов справа налево.

![[Pasted image 20250710093958.png]]

Это сделано для того, чтобы не затерлась область памяти кучи при работе со стеком, ведь рано или поздно, при попадании большого кол-ва данных, которые располагаются в куче могут быть затерты в случае переполнения (стек и куча же, это абстракция, а не аппаратное разделение).

Удобно представлять стек в вертикальном виде, где рост снизу вверх, где ячейки занимают одно машинное слово (16, 32, 64 в зависимости от режима работы процессора). Будет считать, что мы в режиме реальных адресов работаем. Так, все ячейки в последующих примерах будут 16 битными. 

Т.к. стек лежит где то в оперативной памяти, для работы с ним потребуется указатель. Этот указатель носит название регистра `sp - stack pointer`, он указывает на вершину стека и берет адрес последнего добавленного элемента в стек. Именно к нему можно обращаться, чтобы брать данные из вершины стека и добавлять в стек данные. Так же есть указатель на `bp - base pointer`, который *статичен* и указывает на адрес начала фрейма, начиная с которого в стек вносятся или извлекаются значения. 

![[Pasted image 20250710095014.png]]

Есть две операции со стеком - `push` (внести данные в вершину стека), `pop` (извлечь данные с вершины стека).

Как работает `push`:
Пусть, например, нужно положить в стек число 3

```asm
	push 3
```


Сейчас `sp` указывает на адрес последнего внесенного элемента.  После этой команды, адрес, на который указывает `sp` уменьшится на одно машинное слово (2 байта), теперь он указывает на пустую ячейку выше, затем по адресу будет записано число 3

![[Pasted image 20250710095353.png]]

Как работает `pop`:
Пусть теперь надо убрать в с вершины стека значение и поместить в ax. 

```asm
	pop ax
```

Инструкция будет действовать в обратном порядке. 
Берется значение с верхушки стека, возвращается в регистр, затем увеличивается `sp` на 2 байта

![[Pasted image 20250710095014.png]]
### Как со всем этим связаны функции?
Функции - это подпрограммы, куски кода. которые распределены в разных местах.

У каждой такой программы есть свой адрес в памяти, по которому она расположена, используя эти адреса, одна функция может передавать управление другой. Помимо этих возможностей, нам так же надо уметь передавать параметры функции, использовать локальные переменные. Также надо бы уметь возвращать управление вызывающей функции. Это все возможно благодаря стеку.

Мы уже рассматривали то, как изменяется IP. Рассматривая проблемы выше, мы должны уметь возвращать управление от вызванной функции в то место, из которого она вызывалась. 

Для перехода между подпрограммами, в ассемблере есть три команды - `jmp` (прыгает в какой-то участок кода), `call` (перед тем, как перескочить на другой адрес, заносит в стек адрес возврата, после переходит переход), `ret` (используется для возврата внутри вызываемой функции, берет адрес возврата и перепрыгивает на адрес).

В стеке для каждой функции есть своё место, которое называется фрейм функции. Внутри фрейма есть локальное окружение. Все, что вне фрейма - это данные других функций. 
#### Как заносятся функции в стек
В этом помогает `sp` и `bp`, которые делают тот самый фрейм, указывая на адреса начала и конца фрейма функции. 

Формированию фрейма помогает пролог и эпилог функции. Пролог - инструкции в начале выполнения функции и выглядит это так:

Командой `call` помещает адрес возврата и переходим в вызываемую функцию. На текущий момент `bp` указывает на низ фрейма предыдущей функции, с которого заносятся и извлекаются данные.  Фрейм формируется путем сдвига `bp` на самый верх, причем сохраняется начальное значение `bp`, чтобы вернуть все так, как было. Поэтому мы сохраняем текущий адрес `bp`, чтобы его можно было восстановить, далее поднимаем `bp` на самый верх, там где у нас `sp`. Теперь оба регистра указывают на одно и то же место в стеке. `bp` всегда будет статичен, a `sp` будет двигаться, как мы ранее описывали при добавлении элементов. Для доступа к локалям удобнее всего использовать будет `bp`.

![[Pasted image 20250710101653.png]]

Чтобы нам вернуться в место, с которого мы начинали, необходимо нам выполнить инструкции в эпилоге функции - инструкции в конце выполнения функции. Выглядит это так:

Нужно восстановить значение `bp`, сдвинув его на предыдущее место. Для этого сначала возвращаем `sp` к `bp`, в то место, на которое он указывал до начала функции, потом мы `pop`-аем значение `bp` из стека, тем самым передаем в него адрес изначального положения, `sp` растет на одно машинное слово. Для полного возвращения к предыдущему состоянию нам потребуется `ret`-нуться и `sp` теперь будет смотреть на более изначальный адрес. 

![[Pasted image 20250710102539.png]]

Так, например, становится ясно, почему бесконечная рекурсия будет вызывать переполнение стека, ведь она постоянно будет создавать адрес возврата и старый адрес указателя `bp`. 
#### Как происходит передача параметров в функцию
Параметры передаются перед вызовом функции путем добавление в стек, через регистры и через глобальнее переменные. Существует несколько соглашений, как это должно быть реализовано для стека, но самый распространенный выглядит так (std call):

Параметры при таком случае передаются в обратном порядке. Если нужно передать три параметра, то сначала попадет в стек третий, потом второй, затем первый. Далее вызывается функция, в стек заносится адрес возврата, старый адрес `bp`, подтягиваем `bp` к `sp`

![[Pasted image 20250710103800.png]]

Таким образом, доступ к параметрам достигается через несложную арифметику для первого, второго и третьего значения соответственно:

![[Pasted image 20250710103917.png]]

Значения по адресам мы поместили в регистры, теперь процессор может с ними работать.

После того, как функция отработала, можно просто сдвинуть на тот адрес, который был ранее до передачи параметров. 
#### А как по другому?
Ранее был упомянут способы через регистры (быстрее, но есть ограничение на параметры и если параметров больше, чем доступных свободных регистров, то воспользуется стеком) и глобальные переменные (тогда функция не может быть использована рекурсивно). 
#### Как используется стек для хранения локальных переменных
Это необязательно делать через стек, но зачастую это так и делается. 

Область памяти в стеке для локальных переменных называется стековым кадром или стековым фреймом. После его формирования мы сохраним значение `bp` в стеке на вершину, далее переместим указатель к вершине стека. Функция может себе создать место под локали путем выделения области памяти в кол-ве, необходимом для переменных, поставив `sp` на то кол-во байт, необходимых для локалей. Обращаться можно будет через `bp`, т.к. он всегда статичен, вычитая нудное кол-во байт для нахождения адреса. 

![[Pasted image 20250710105204.png]]

Далее, когда будут восстанавливаться указатели, мы передвинем `sp` к `bp` и попнем `bp`. Тем самым, мы избавимся от локалей, которые больше не нужны. 

![[Pasted image 20250710105320.png]]

