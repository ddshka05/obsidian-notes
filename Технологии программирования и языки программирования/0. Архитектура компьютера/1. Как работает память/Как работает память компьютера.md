**Память** - это компонент компьютера, способный хранить в себе различную информацию (программы, картинки, текст). 

Когда мы говорим, что что-то весит больше, чем другое, это означает, что просто двоичное число, которое необходимо записать на компьютер больше другого. 
### Классификации памяти
- Регистры (на самом процессоре)
- Кэш-память (хранилище для часто используемых процессором данных)
	 Существует несколько уровней кэша
- Оперативная память (именно в этой памяти зачастую хранятся программы).
- Внешние накопители (SSD, HDD, флеш-накопители и тп.)

![[Pasted image 20250703112353.png]]

Скорость здесь характеризуется как время доступа процессора к памяти.

Оперативная память включает в себя набор ячеек. 

Бит - минимальная единица информации. Он может быть либо включен (1), либо отключен (0). Они образуются в группы по 8 штук, образуя байты. Байт - это минимально адресуемая ячейка (октета) памяти. 

Именно поэтому для хранения типа boolean требуется 1 байт, т.е. 8 бит, хотя было бы достаточно 1 бита для хранения такой информации. 

Устроен каждый байт оперативной памяти так:
- Имеет адрес
- Разделяют старший бит и младший бит
### Виды адресации
Различают байтовый и словесный тип адресации

Байтовый характеризуется тем, что у каждого байта есть свой адрес 

![[Pasted image 20250703112803.png]]

Словесный характеризуется тем, что память хранит информацию ячейками размером в машинное слово.  **Машинное слово** - это максимальное количество бит, которым может оперировать компьютер за раз - то есть обмениваться с памятью данными, хранить в регистрах и т.п. 
#### Почему сейчас компьютеры в основном с байтовой адресацией
Потому что так удобнее обрабатывать текс - основной тип данных, с которым работает пользователь. 

Во-первых, самый первый стандарт кодировки ASCII кодирует символы в 7 бит. При таком условии байтовая адресация выглядит куда более оптимизированной (всего один бит ненужный, а для 64 битного процессора, например, 57 бит ненужные). А далее UTF-8, 16, 32 используют кодировки, кратные 8, что так же делает байтовую адресацию лучше.

Во-вторых, процессору легче и быстрее работать при байтовой адресации. Например, стало нужным изменить символ, где каждый символ закодирован в 1 байт, тогда нужно просто изменить этот 1 байт для изменения символа. При словесной адресации слово бы либо хранилось полностью в машинном слове, тогда процессор бы искал, какие там ему биты надо поменять, либо же каждый символ был бы машинным словом, что, как мы уже поняли не является оптимальной тратой памяти.

Подобного рода компьютеры со словесно адресацией предназначены для научных вычислений с числами.
### Порядок хранения байтов
Существует два типа хранения байтов в оперативной памяти:
- big endian (байты слева направо) - прямой порядок
- little endian (байты справа налево) - обратный порядок

Например, число 1240 может храниться так (big endian)
![[Pasted image 20250703114949.png]]

Либо вот так (little endian)
![[Pasted image 20250703114958.png]]

Причем биты расположена в прямом порядке, не меняют своего положения
### Выравнивание
Выравнивание по естественным границам - организация оперативной памяти в соответствии с машинным словом процессора.

Процессор считывает машинные слова себе в регистр, поэтому, если информация будет располагаться по хаотичным адресам, то тогда процессор будет тратить много времени на обращение, либо совсем не сможет обращаться.

Пусть процессор 16-битный процессор. Тогда машинное слово должно быть выравнено по адресу кратному двум (0, 2, 4, 6, 8,...)

![[Pasted image 20250703115553.png]]

Иначе, процессор бы считал несколько адресов. Это проблема, если машинное слово начинает пересекать естественные границы выравнивания. 
### Виды типов данных
Существует два вида типов данных:
- ссылочные
- примитивные

Числовые типы данных (byte (char), short, int, long) относятся к примитивам, это значит что они копируются по значению, а не по ссылке.

Это значит, что при копировании переменной в уже существующую переменную, выделяется новый участок памяти под эту переменную, две переменные не зависят теперь друг от друга и содержат одинаковые данные. 

```c
char a = 5;
char b = a; // мы создали новую переменную, с новым адресом, которая хранит 5
```

Переменная а и b ссылаются на разные значения в памяти, что делает их независимыми (изменяя одну не меняем другую).

Ссылочные типы данных же являются массивы. Массив - это структура данных, в которой каждый элемент имеет индекс от 0 до n-1, где n - длина массива. Бывают статические и динамические массивы. 

Т.к. все элементы находятся рядом другу с другом, что делает этот тип данных очень быстрым. Для поиска любого элемента массива, необходимо знать адрес начала массива, индекс искомого элемента, размер элементов массива. 

```c
char arr[] = {2, 4, 5, 7, 9};
```

Так ссылка на начало массива хранится в `arr[]`, а размер элементов массива `char` - то есть 1 байт.  Пусть например хотим достать 3-тий элемент. Тогда мы найдем его примерно применяя такие вычисления: к адресу начала массива прибавим индекс искомого и умножим на размер элементов массива.
 ![[Pasted image 20250703121355.png]]

Если же создать новую переменную того же типа и присвоим старый массив новой переменной, то тогда в переменную скопируется ссылка на этот элемент в памяти компьютера

```c
char arr[] = {2, 4, 5, 6};
char copy = arr; // ссылаемся на этот массив в памяти, не создавая новый
```

Таким образом, меняя copy, мы будем менять arr.
### Мусор в памяти 
ЯП подразделяются на языки с автоматическим управлением (Python, Java) и ручным управлением памятью (С, С++). 
