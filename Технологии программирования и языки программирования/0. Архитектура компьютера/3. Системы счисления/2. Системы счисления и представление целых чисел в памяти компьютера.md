	### Десятичная система
Самая привычная система счисления, досталась от арабов нам. 

Цифры: $0, 1, 2, 3, 4, 5, 6, 7, 8, 9$
Представление: $7845 = 7 * 10^3 + 8 * 10 ^ 2 + 4 * 10 ^ 1 + 5 * 10 ^ 0$
### Двоичная система
Вспомним, что 1Б (байт) соответствует 8б (бит), также байт - это минимально адресуемая область памяти компьютера. 

Тогда рассмотрим операции на примере для 8 бит. 

0 для нам - это значит выключен, а 1 - включен. 

Имеем схему кодирования следующую
```
Двоичная   Десятичная
00000000 = 0
00000001 = 1
00000010 = 2
00000011 = 3
00000100 = 4
...
11111111 = 255
```

Таким образом, вы покрываем интервал от 0 до 255. То есть, в восьми битах можно закодировать любое целое неотрицательное число в диапазоне \[0; 255\]. А представление чисел в виде последовательности нулей и единиц получило название **двоичной формой** записи числа. Что соответствует **двоичной системе счисления**.

Показанный алгоритм формирования двоичных комбинаций и их нумерация десятичными числами от 0 до 255 имеет достаточно простое математическое выражение. Предположим, что перед нами записано некоторое число в двоичной форме:

$00011001 = 1*2^4 + 1 * 2^3 + 1 * 2^0 = 25$
#### Переполнение
А что будет, если мы захотим занести в эти восемь бит следующее число (255 + 1 = 256). Из-за того, что у нас всего восемь бит, а не девять, то мы получим, 00000000 = 0. 

А что будет, если мы вычтем из 0 единицу? (0 - 1 = -1). Мы получаем 255. 

Эти дефекты операций называются переполнениями. 

Это также означает, что все операции происходят по модулю кол-ва бит, которое кодирует целевое число. В данном случае по модулю $2^N, N = 16$ 
### А как представить отрицательные целые числа
Как это можно было бы сделать? На самом деле подход очень простой и вытекает из только что установленного факта: если из нуля вычесть один, то получим 255. Но ничто нам не мешает вместо 255 кодировать значение -1. И вычитать и далее.

Принято, что если старший бит, то есть бит с самым большим разрядом, 0 - число положительное, а если 1 - отрицательное.

Таким образом мы получаем:
```
11111111 = -1 
11111110 = -2  
11111101 = -3  
11111100 = -4
...
10000000 = -128
```

Отсюда получаем диапазон для представления отрицательных и положительных чисел в одном байте от -128 до 127.

Вообще в памяти компьютера отрицательные числа хранятся по методу two's complement representation. То есть 

$-x = \overline{x} + 1$ (побитвая инверсия и сложение с единицей). 

Наоборот, чтобы получить из двоичного отрицательного числа, закодированным методом дополнительного кода, нужно вычесть единицу и побитого инвертировать. (выводится из верхнего). 

$\overline{-x - 1} = x$ 

| Биты     | Число |
| -------- | ----- |
| 0000     | 0     |
| 0001     | 1     |
| 0010     | 2     |
| 0011     | 3     |
| 0100     | 4     |
| 0101     | 5     |
| 0110     | 6     |
| **0111** | 7     |
| **1000** | -8    |
| 1001     | -7    |
| 1010     | -6    |
| 1011     | -5    |
| 1100     | -4    |
| 1101     | -3    |
| 1110     | -2    |
| 1111     | -1    

Заметим, что у нас все зеркально на инверсию относительно чуть выше нуля (мы же + 1 прибавляем). 

Но если мы например к `0111` прибавим 1, то получим `1000`, что равно -8, это знаковое переполнение, то есть от неверных арифм. результатов нам никуда не деться. 
#### Но 127 и 255 - это же мало...
Не беда! Можно отвести и большее количество байт под хранение целых чисел. Таким образом можно отвести два байта (16 бит), и так далее. Обычно ограничиваются 8 байтами. 
### Шестнадцатеричная система
Давайте снова вернемся к одному байту, состоящего из восьми бит:
![[Pasted image 20250701131715.png]]

Можно заметить, что каждая его половинка состоит из четырех бит. И мы легко можем рассчитать число возможных вариантов, которые кодируются этими четырьмя битами:

$2 ^ 4 = 16$

То есть можно не писать колбасу из восьми 0 и 1, а просто записать два числа в 16-ричной системе счисления. Таким образом:

Цифры в 16-ричной системе: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

Можно так же сделать таблицу, для удобного перевода из двоичной в 16-ричную систему.
```
0000 0         1000 8
0001 1         1001 9
0010 2         1010 A
0011 3         1011 B
0100 4         1100 C
0101 5         1101 D
0110 6         1110 E
0111 7         1111 F
```

Представление числа из двоичной в шестн.: $10110001 = B1$
### Восьмеричная система
Даёт возможность удобного представления пар из 3 бит. Достаточно распространена была ранее. 

000 0
001 1
010 2
011 3
100 4
101 5
110 6
111 7