![[Pasted image 20250703150841.png]]

Сначала импортируем библиотеку `sys` 
## Потоковый ввод

В Python существует один очень полезный встроенный объект, который называется поток ввода (`sys.stdin`).

Поток ввода (`sys.stdin`) — это специальный объект в программе, куда попадает весь текст, который ввёл пользователь. Потоком его называют потому, что данные хранятся в нем до тех пор, пока программа их не прочитала. 

Таким образом, данные поступают в программу и временно сохраняются в потоке ввода (`sys.stdin`), а программа может забрать их оттуда, например, с помощью встроенной функции `input()`. В момент прочтения данные пропадают из потока ввода, так как он хранит их до тех пор, пока они не будут прочитаны.

Поток ввода (`sys.stdin`) — является **итератором**, который невозможно перезапустить. Как и любой итератор, он может двигаться только вперёд. Как только данные прочитаны, они удаляются из потока ввода безвозвратно. Элементы, которые выдает этот итератор — это строки, введённые пользователем. Если пользовательский ввод закончен, то итератор прекращает работу. Пока пользователь не ввёл последнюю строку, мы не знаем, сколько элементов в итераторе.
#### Элементарная программа
Напишем программу, которая дублирует каждую введённую пользователем строку.
```python
import sys

for line in sys.stdin:
    print(line.strip('\n'))
```

Пока есть данные в потоке ввода `sys.stdin` (то есть пока пользователь их вводит) программа будет записывать вводимые строки в переменную `line`, убирать символы перевода строки и выводить их на печать.

Если запустить такую программу, то она будет работать вечно. Чтобы показать, что ввод закончен, недостаточно нажать `Enter` — компьютер не знает, завершил ли пользователь работу или будет ещё что-то вводить (при этом `Enter` превратится в пустую строку).

Для завершения ввода необходимо ввести `Ctrl + D` (если работаете в консоли Linux или IDE PyCharm), либо `Ctrl + Z`, затем `Enter` (если работаете в консоли Windows).
#### Читаем входные данные в одну строку
С помощью потока ввода (sys.stdin) можно в одну строчку кода прочитать весь пользовательский ввод в список.

Реализуется это с помощью списочного выражения:
```python
import sys

data = [line.strip() for line in sys.stdin]
```

или с помощью функции высшего порядка map():

```python
import sys

data = list(map(str.strip, sys.stdin))
```

**Замечание:**
Обратите внимание, что мы ничего не знаем о количестве введенных строк. Раньше приходилось в задачах сначала указывать количество строк, а уже затем сами строки.

Таким образом если мы не знаем, в какой момент надо прекратить ввод, то воспользоваться функцией `input()` не удастся, т.к. он нам просто не даст начать программу без исключений. Он будет выкидывать `EOFError: EOF when reading a line.`, что означает, что `EOF` (то есть `end of file`) программа получила раньше, чем получила все данные для инпутов. 

В таких случаях остаётся только работать с потоковым вводом (`sys.stdin`).

Как уже было сказано выше, мы можем обойти циклом `for` итератор `sys.stdin`. Кроме того, можно считать все строки из итератора (с сохранением символов перевода строки) в список с помощью метода `readlines()` или же просто считать всю строку методом `read()`.
## Потоковый вывод

Аналогичным образом можно работать с потоковым выводом (`sys.stdout`). По умолчанию функция `print()` перенаправляет вывод данных именно в `sys.stdout`, хотя нам ничего не мешает самостоятельно писать в него.

```python
import sys

print('Hello')
sys.stdout.write('world!')
print('from')
sys.stdout.write('python\n')
print('Bye-bye')
```

Обратите внимание на то, что функция `print()` добавляет перевод на новую строку, а явная запись данных в `sys.stdout` с помощью метода `write()` нет. Чтобы добавить перевод на новую строку, мы используем стандартный escape-последовательность `\n`.

Также нужно иметь в виду, что при использовании потока вывода `sys.stdout` нам нужно самостоятельно преобразовывать данные к строковому типу данных (функция `print()` это делает автоматически).

Приведенный ниже код:

```python
import sys

sys.stdout.write(17)
```

приводит к возникновению ошибки, ведь `stdout` ожидает, что приходящая информация - это текст.

Надо добавить `str(17)`
## Примечания

**Примечание 1.** По умолчанию функция `input()` читает данные из потока ввода `sys.stdin` (который в свою очередь по умолчанию принимает с клавиатуры), а функция `print()` печатает данные в поток вывода `sys.stdout`(который по умолчанию направляет на экран).

**Примечание 2.** Функция `print()` — это удобная обертка (wrapper) вокруг метода `sys.stdout.write()`. Функцию `input()` часто можно рассматривать как обертку (wrapper) вокруг `sys.stdin.readline()`.

**Примечание 3.** Объекты `sys.stdin` и `sys.stdout` являются файловыми объектами, предоставляемыми ОС. Им доступны все соответствующие методы (`read(), readline(), readlines(), write(), writelines()`). Таким образом, для `stdin` доступно чтение из него - то есть `read(), readline(), readlines()`, а для `stdout` доступна запись в него - `write(), writelines()`. 

Мы так же можем перенаправлять поток ввода или вывода в другие файлы.

Приведенный ниже код:

```python
import sys

temp = sys.stdout                         # сохраняем исходный                                             потоковый вывод
sys.stdout = open('log.txt', 'w')         # перенаправляем                                                 потоковый вывод в                                              файл
print('testing123')
print('another line')
sys.stdout.close()
sys.stdout = temp                         # восстанавливаем                                                исходный потоковый                                             вывод
print('back to normal')
```

приведет к созданию текстового файла `log.txt`, содержащего:

```
testing123
another line
```

### Преимущество потокового ввода и вывода
Считывание напрямую из него работает быстрее, чем через встроенные функции питона. 