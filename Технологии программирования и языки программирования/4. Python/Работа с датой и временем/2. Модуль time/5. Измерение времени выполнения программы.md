Лучше всего использовать третий способ подсчета времени работы программы!

Существует также другой модуль для измерения времени работы программы - модуль `timeit` [[3.0. Полезные заметки, что почитать и что дальше можно учить по этой теме]]

Существует три способа, как посчитать время выполнения программы через модуль `time`
### С помощью `time()`
```python
import time

start_time = time.time()

for i in range(5): 
    print(i)
    time.sleep(1)

end_time = time.time()

elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')
```
выводит (время работы программы может незначительно отличаться):

```no-highlight
0
1
2
3
4
Время работы программы = 5.022884845733643
```

Несмотря на простоту вышеописанного подхода, использовать его в серьезных целях, где требуется точный и независимый от операционной системы (ОС) результат, не рекомендуется. 

Все дело в том, что числовое значение времени, получаемое таким образом, может иметь погрешности за счет внутренних особенностей работы компьютера, в среде которого выполняется программа. Более того, системные часы (которыми пользуется `time()`) могут быть подкорректированы вручную пользователем во время выполнения программы. 

Может даже случиться такая ситуация, что очередной вызов функции `time()` вернет значение меньше, чем значение, полученное при предыдущем вызове.
### С помощью `monotonic()` или `monotonic_ns()`
**Замечание:**

`monotonic_ns()` выводит время в наносекундах, доступно не на всех ОС

Для измерения времени выполнения программы идеально подходит функция `monotonic()`, доступная на всех ОС (начиная с Python 3.5), так как ее результат не зависит от корректировки системных часов.

Используемый таймер в функции `monotonic()` никогда не вернет при повторном вызове значение, которое будет меньше значения, полученного при предыдущем вызове. Это позволяет избежать многих ошибок, а также неожиданного поведения.

В следующем примере демонстрируется применение функции `monotonic()` для получения текущего времени, чтобы в итоге выявить, как долго работал блок кода.

Приведенный ниже код:

```python
import time

start_time = time.monotonic()

for i in range(5): 
    print(i)
    time.sleep(0.5)

end_time = time.monotonic()

elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')
```

выводит (время работы программы может незначительно отличаться):

```no-highlight
0
1
2
3
4
Время работы программы = 2.547000000020489
```

**Замечание:** Принцип работы и применения функции `monotonic()` такой же, как и у функции `time()`. Однако функция `monotonic()` дает результат, который обладает гарантированной точностью и не зависит от внешних условий.
### Функция `perf_counter()` или `perf_counter_ns()`
**Замечание:**
`perf_counter_ns()` - выводит время в наносекундах, доступно не на всех ОС

Для самого точного измерения времени выполнения программы следует использовать функцию `perf_counter()`. Данная функция использует таймер с наибольшим доступным разрешением, что делает эту функцию отличным инструментом для измерения времени выполнения кода на коротких интервалах.

В следующем примере демонстрируется применение функции `perf_counter()` для получения текущего времени, чтобы в итоге выявить, как долго работал блок кода.

Приведенный ниже код:

```python
import time

start_time = time.perf_counter()

for i in range(5): 
    print(i)
    time.sleep(1)

end_time = time.perf_counter()

elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')
```

выводит (время работы программы может незначительно отличаться):

```no-highlight
0
1
2
3
4
Время работы программы = 5.042140900040977
```

